<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>BroadView&trade; API Guide and Reference Manual: Design</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BroadView&trade; API Guide and Reference Manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Welcome</span></a></li>
      <li class="current"><a href="../../pages.html"><span>BroadViewâ„¢&#160;Documentation</span></a></li>
      <li><a href="../../modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d8/db7/OPENAPPS_GUIDE.html">Software Overview</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Design </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="INTRO"></a>
Introduction</h1>
<p>This section provides a high level overview of the agent functionality.</p>
<p>The BroadView&trade; Instrumentation Agent establishes communication with underlying silicon. It collects various instrumentation statistics, processes and packages the data appropriately and provides the data to an interested Collector. Similarly, the Agent configures the silicon based on the configuration requests from the Collector.</p>
<p>The Agent communicates with Collector using REST-style communication, with the data exchange in JSON-RPC (2.0) format. The Agent supports both the pull model of operation (Collector requests data and obtains it) as well as push model of operation (Agent sends periodic reports, asynchronously).</p>
<p>The BroadView&trade; Instrumentation Agent software consists of various blocks of components. The design is modular and extensible and enables easy customization and integration into a NOS. Some of the components are meant for porting and/or customization and the default implementations of those components are for illustrative purposes. For example, by default, the Agent software doesn't support any authentication or security for the communication with the Collector. However, the security and webserver modules can be easily enhanced or added to provide necessary additional functionality. Subsequent chapters detail various customizations that are possible.</p>
<h1><a class="anchor" id="CONFIG"></a>
Stored Configuration</h1>
<p>The Agent stores the configuration locally in a text-file and applies it upon startup. If startup configuration file is not available, the default configuration is used.</p>
<p>The configuration stored is very minimal, and contains the minimal settings needed for communicating with the Collector. The Collector is required to configure the agent for the instrumentation features, if the default configuration is not considered sufficient.</p>
<h1><a class="anchor" id="OS"></a>
Operation in Linux OS</h1>
<p>Various components of the Agent (described in next section) are compiled and linked into a single Linux-executable. This user-space executable (as a single process) runs multiple threads within, based on the needs.</p>
<p>Typically each of the Instrumentation feature modules start and maintain a thread. The API invoked by the collector is to be executed in corresponding feature/module thread context. More details on multi-threaded behavior are described in a later section.</p>
<p>In addition, there is a system-wise timer thread meant for the periodic data collection. The other modules register their data gathering functions with the system data-collection thread, and suggest the periodicity with which the functions need to be invoked. The registered callbacks are invoked in the data-collection thread context, and care must be taken by the callbacks to ensure data integrity.</p>
<p>The components in the agent use POSIX API for any required inter-thread communication.</p>
<p>No kernel space operations are performed within the agent process. Multiple agent instances running in a single Linux environment is not supported.</p>
<h1><a class="anchor" id="STACK"></a>
Operation in a Stack</h1>
<p>It may be possible that the agent is running on multiple platforms connected in a stacked formation. In a conventional method, the agent running on the stack manager must provide a necessary facade for the other agent instances in the stack. It must provide a unified interface to the collector for all the agents in the stack. The current design doesn't envisage any agent running such a facade. In other words, the collector must communicate to the agents independently and gather the data.</p>
<h1><a class="anchor" id="DESIGN"></a>
Design</h1>
<div class="image">
<img src="../../ReferenceAgent.jpg" alt="ReferenceAgent.jpg"/>
<div class="caption">
Reference Agent Implementation</div></div>
<p> Various components that are part of the Agent software are divided into four blocks, namely the NB Plugin Block, Instrumentation Block, SB Plugin Block and the Infrastructure Block. Each of these blocks is described below.</p>
<h1><a class="anchor" id="NBPLUGIN"></a>
NorthBound Plugin Block</h1>
<p>The NB Plugin block is responsible for setting up and managing the communication with the Apps/Controller(s)/Collector(s), henceforth referred to as collectors, which interface with the Reference Agent. The distribution includes a Reference App which will exercise the NB API of the Reference Agent.</p>
<p>The agent uses REST-style communication to communicate with the collector, with the data exchange in the JSON-RPC format. The REST and the Web Server components handle these interactions with the collectors. The REST component extracts the incoming JSON-RPC request, deciphers the API being invoked by the Collector, and passes-on the JSON message to appropriate Instrumentation Block component (using the Module Manager Component services).</p>
<p>The Discovery component is responsible for detecting the presence of one or more collectors on the network and establishing communication between the agent and the device. It also maintains a heartbeat channel with the collector for detecting any loss of communication.</p>
<p>The Security component provides the necessary encryption support for the communication between the Agent and the Collector. It also provides the necessary authentication for the discovered Collectors.</p>
<p>The Load Balancer component provides the notion of active and standby collectors. It keeps track of communication errors with the designated active collector. In the event of persistent failures, this component switches the standby collector to active state, and establishes the communication with it.</p>
<h1><a class="anchor" id="DEFAULT_IMPL"></a>
Default Implementations</h1>
<p>The default implementation of the Discovery module reads the Active Collector IP address and Communication Port numbers from a pre-defined configuration file.</p>
<p>The Security Module is not provided as part of reference implementation. It means that the agent allows unencrypted communication between the Collector and the Agent. Likewise, the Collectors are considered genuine, and no attempt is made to validate the authenticity of the collector.</p>
<p>The Load Balancer module is not provided as part of reference implementation. Any errors either during the pull or during the push operations are logged and communication is re-attempted.</p>
<h1><a class="anchor" id="INFRA"></a>
Infrastucture Block</h1>
<p>The infrastructure block provides the necessary infrastructure and utilities for the other modules in the Agent.</p>
<p>The Logging component provides logging functionality to the Agent system. It provides API functions which can be used for logging various events / data. Different levels of logging are supported.. The Module Manager component provides for registration of various Instrumentation components with the Agent. Each of the Instrumentation components must register with Module Manager, with the details of various APIs it supports, the feature identification, supported silicon, and the callback functions that process the API. When an API is invoked by the Collector, the Module Manager component assists the REST component in invoking the appropriate handler for the API, based on the registration information.</p>
<p>The Instrumentation components are typically C code. linked with the agent. The components register the supported REST API with the Module Manager at run time, during the initialization process.</p>
<p>The System component is the in-charge component for setting up the agent based on the configuration and starting / stopping various other components as needed. The System component also provides the Timer API which can be used by the other components for periodic data collection by the hardware. It must be noted that the periodic data collection may be disabled / enabled by the Collector on a system-wide basis, or selectively on a per-component basis.</p>
<h1><a class="anchor" id="REF_IMPL"></a>
Reference Implementation</h1>
<p>The Reference Implementation of the Logging component uses syslog. It can be easily enhanced to use a simple sqlite3 database.</p>
<h1><a class="anchor" id="SB_PLUGIN"></a>
SouthBound Plugin Block</h1>
<p>This block features different plug-in modules that conform to the SB-API specification. Each of the Plugins registers with the SB-Plugin Redirector component, with the list of features as well as the silicon that are supported by the Plugin. When any instrumentation component desires to communicate to the Silicon, it invokes the corresponding API of the SB-Plugin Redirector component, which in turns uses the registration information to invoke corresponding Plug-in component. The goal behind having the SB-Plugin is to allow functions to be written specific to the mechanism that is available to obtain the instrumentation information from the Silicon on any specific system. E.g. System 1 could allow use of SDK API while System 2 may have its own API (say OpenNSL API). We do not expect two different SB-plugins to register with the SB-Plugin Redirector at the same time.</p>
<p>The SB-Plugin modules are typically shared object libraries linked with the agent. The Plugin registration is done by invoking the SB-Plugin Redirector component's registration API.</p>
<h1><a class="anchor" id="REF"></a>
Reference Implementation</h1>
<p>The Reference Implementation consists of an SDK SB Plugin</p>
<h1><a class="anchor" id="INSTRU_BLK"></a>
Instrumentation Block</h1>
<p>This section describes the general behavior of the components that are part of this block.</p>
<p>The Instrumentation components are registered statically with the Agent. Upon startup, the Agent invokes the init() for each of the registered components as part of the initialization sequence. The components are required to register the supported silicon, features and the REST API with the Module Manager component. For example a BST component developed for TD2 silicon would register as follows :</p>
<p>modulemgr_register( SILICON_TD2, FEATURE_BST, { BST_GET_STATS, BST_SET_TRIGGERS} );</p>
<p>Such registration enables the Module Manager to understand the set of REST API that is supported by the entire Agent. Any feature configuration REST API is also included in the registration.</p>
<p>The Web server thread invokes the API Handler function with the JSON message buffer.</p>
<p>The supported data formats - both for the API (commands) and the responses are documented in XML format. A tool is run on these XML files, which can generate C code that can parse the JSON buffer and convert the incoming data to appropriate C Structure. This generated code is used as implementation for the handler functions. Once the C Structure is derived, control is handed over to the component thread. The web server thread acknowledges the REST API to the Collector.</p>
<p>The component, under its own thread context now, makes appropriate function calls to process the request and invoke appropriate SB-Plugin API calls. It is also likely that the component may not be required to make any SB-Plugin calls, for fulfilling the REST API, since the data may be collected by the periodic thread already. Once all the required data is available, the data is converted into JSON and using a web server API function, the data is sent back to the Collector.</p>
<h1><a class="anchor" id="THREAD"></a>
Design: Threads View</h1>
<p>The diagram below depicts the three major thread contexts in the Agent System. It is important to understand these contexts for ensuring the data integrity.</p>
<div class="image">
<img src="../../ThreadView.jpg" alt="ThreadView.jpg"/>
<div class="caption">
Threads View</div></div>
<p> When a Collector invoked REST API is being processed, there are typically two threads involved.</p>
<p>The processing of the request received in JSON format, up to the time when the JSON is converted into an appropriate C structure is done as part of the web server thread context. The request is handed over to the Component thread, and the collector is acknowledged.</p>
<p>Subsequent processing of the request is done as part of the Instrumentation component's thread. Within the same context, the appropriate SB-Plugin API is invoked and corresponding data is obtained and sent back to the Collector.</p>
<p>When the periodic data collection thread is running, all of the processing is done within the same context of the data collection Thread.</p>
<h1><a class="anchor" id="IPC"></a>
IPC and thread safety</h1>
<p>The components use locks (pthread_mutex) for guarding critical regions when modifying shared memory.</p>
<p>Each Instrumentation component maintains its own message queue. For each incoming REST API, the web server thread posts the data to this message queue. The component thread blocks until a message is available on this queue and processes it. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 30 2015 18:57:39 for BroadView&trade; API Guide and Reference Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
